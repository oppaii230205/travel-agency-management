# Project Proposal

## Thành viên nhóm

1.  _Võ Cao Tâm Chính_  
    MSSV: **23120194**
2.  _Nguyễn Hưng Thịnh_  
    MSSV: **23120200**

## Phân chia công việc

| STT | Họ tên | Vai trò | Công việc | Tỷ lệ phân chia công việc |
| --- | --- | --- | --- | --- |
| 1   | Nguyễn Hưng Thịnh | Nhóm trưởng | Tạo Github Repositories cho dự án, xác định kiến trúc phần mềm, tổng hợp các nguyên tắc OOP, Design Pattern cần tuân thủ, thiết kế và xây dựng các lớp, chức năng thêm chuyến đi và đặt chuyến đi. Thiết kế UI cho các chức năng đã viết, video hướng dẫn sử dụng. | 50% |
| 2   | Võ Cao Tâm Chính | Thành viên | Tạo máy chủ Azure Clouds để lưu trữ Database, tạo cơ sở dữ liệu, tổng hợp các Coding Convention cần tuân thủ, thực hiện Unit test các thành phần đã hoàn thiện. Thiết kế và xây dựng các lớp, chức năng người dùng, đăng nhập tài khoản, đăng ký tài khoản, đăng xuất. Thiết kế UI cho các chức năng đã viết. | 50% |

## Báo cáo tiến độ dự án

**Tên dự án**: Travel Agency Management System  
**Ngày báo cáo**: 05/05/2025  
**Giai đoạn**: Phát triển chức năng sản phẩm  
**Người phụ trách**: Nguyễn Hưng Thịnh - Võ Cao Tâm Chính

**Tóm tắt tiến độ**

- Tiến độ tổng thể: 52% hoàn thành
- Tiến độ so với kế hoạch: Đúng tiến độ

**Công việc đã hoàn thành**

| STT | Hạng mục | Trạng thái | Ghi chú |
| --- | --- | --- | --- |
| 1   | Thống nhất tài liệu mô tả coding convention | Hoàn thành |     |
| 2   | Xây dựng CSDL trên SQL Server | Hoàn thành |     |
| 3   | Thiết kế lại mã nguồn hướng đối tượng | Hoàn thành |     |
| 4   | Thiết kế giao diện (UI) | 70% | Bố cục chưa hợp lý cần điều chỉnh lại |

**Công việc đang thực hiện**

| STT | Hạng mục | Trạng thái | Ghi chú |
| --- | --- | --- | --- |
| 1   | Viết mã nguồn cho toàn bộ dự án | 40% | Hoàn thành các lớp cơ bản phục vụ cho chương trình. Chưa có các chức năng cải tiến |
| 2   | Vẽ giao diện cho sản phẩm | 40% | Hoàn thành đăng nhập, đăng ký, đăng xuất, thêm chuyến đi, đặt chuyến đi, lấy danh sách chuyến đi |

**Công việc sắp tới**

- Chuẩn bị tài liệu kiểm thử sản phẩm.
- Hoàn thành nhật kí, báo cáo, tài liệu giới thiệu.
- Hoàn thành Auto-generated Documentation.

**Đánh giá rủi ro & đề xuất**

- Rủi ro

   \+Chậm tiến độ do yêu cầu phức tạp khi sử dụng API lấy dữ liệu thời tiết.

   \+ Thiết kế lại bố cục giao diện.

- Đề xuất

   \+ Tăng cường testing trước khi release.

   \+ Tăng cương trao đổi giữa các thành viên để thống nhất ý tưởng.

**Kết luận**

Dự án đang tiến triển ổn định, cần tập trung vào các khâu **xây dựng hệ thống** và **kiểm thử** để đảm bảo đúng timeline.

## Minh chứng họp nhóm

### Minh chứng họp nhóm lần 1

**Thông tin chung**
- Thời gian bắt đầu: 21h00, ngày 08/04/2025
- Thời gian kết thúc: 21h30, ngày 08/04/2025
- Địa điểm: Google Meet (<https://meet.google.com/jjp-fsff-oae>)
- Thành viên có mặt:
   \+ Nguyễn Hưng Thịnh (Trưởng nhóm)
   \+ Võ Cao Tâm Chính
- Vắng mặt: Không

**Nội dung**
- Đề xuất ban đầu:
   \+ Đề tài 1: Travel Agency Management System
   \+ Đề tài 2: Game Cờ Vua
- Thảo luận
Đề tài 1:
      -- Dễ dàng phân tích thành các đối tượng (Class) như User, Trip, Booking với quan hệ rõ ràng (kế thừa, đa hình).
--- Dễ dàng thêm tính năng mới.
--- Có tính ứng dụng thực tế.
--- Xử lý được các nghiệp vụ phức tạp (quản lý đặt tour, hủy tour).
   Đề tài 2:
--- Các đối tượng dễ định nghĩa áp dụng được tính đa hình.
--- Chủ yếu xử lý luật game, it nghiệp vụ phức tạp.
--- Khó ứng dụng chủ yếu phục vụ học thuật
--- Ít cơ hội tích hợp API, cơ sở dữ liệu
- Biểu quyết:
Cả nhóm nhất trí chọn đề tài 1 (Travel Agency Management System) với 2/2 số phiếu

Phân công công việc

| STT | Họ tên | Vai trò | Công việc | Tỷ lệ phân chia công việc |
| --- | --- | --- | --- | --- |
| 1   | Nguyễn Hưng Thịnh | Nhóm trưởng | Tạo Github Repositories cho dự án, xác định kiến trúc phần mềm, tổng hợp các nguyên tắc OOP, Design Pattern cần tuân thủ | 50% |
| 2   | Võ Cao Tâm Chính | Thành viên | Tạo máy chủ Azure Clouds để lưu trữ Database, tạo cơ sở dữ liệu, tổng hợp các Coding Convention cần tuân thủ | 50% |

**Cam kết chung**
- Tuân thủ deadline và các quy tắc lập trình.
- Họp đột xuất nếu có vấn đề phát sinh

**Kết luận**
- Đề tài chính thức: Travel Agency Management System
- Công cụ sử dụng:
\+Quản lý dự án: Github
\+ Frontend: Qt
\+ Backend: C++
\+ Database: SQL Server + Azure Clouds

### Minh chứng họp nhóm lần 2

**Thông tin chung**
- Thời gian bắt đầu: 21h00, ngày 24/04/2025
- Thời gian kết thúc: 21h30, ngày 24/04/2025
- Địa điểm: Google Meet (<https://meet.google.com/jjp-fsff-oae>)
- Thành viên có mặt:
\+ Nguyễn Hưng Thịnh (Trưởng nhóm)
\+ Võ Cao Tâm Chính

- Vắng mặt: Không

**Nội dung họp**
Đánh giá mực độ hoàn thành công việc:

| Họ Tên | Mức độ hoàn thành | Ghi chú |
| --- | --- | --- |
| Nguyễn Hưng Thịnh | 85% | Nghiên cứu bổ sung thêm Design Pattern |
| Võ Cao Tâm Chính | 85% | Số lượng Coding Convention còn hạn chế cần bổ sung thêm |

Đánh giá tiến độ đồ án
\+ Tiến độ tổng thể: 19.5% hoàn thành
\+ Tiến độ so với kế hoạch: Đúng tiến độ

Phân công công việc mới
| STT | Họ tên | Vai trò | Công việc | Tỷ lệ phân chia công việc |
| --- | --- | --- | --- | --- |
| 1   | Nguyễn Hưng Thịnh | Nhóm trưởng | Thiết kế và xây dựng các lớp, chức năng thêm chuyến đi và đặt chuyến đi. Thiết kế UI cho các chức năng đã viết, tạo video demo và tài liệu hướng dẫn. | 50% |
| 2   | Võ Cao Tâm Chính | Thành viên | Thiết kế và xây dựng các lớp, chức năng người dùng, đăng nhập tài khoản, đăng ký tài khoản, đăng xuất. Thiết kế UI cho các chức năng đã viết. Thực hiện Unit test các thành phần đã hoàn thiện. | 50% |

**Cam kết chung**
- Tuân thủ deadline và các quy tắc lập trình.
- Họp đột xuất nếu có vấn đề phát sinh

**Kết luận**
- Các thành viên đều hoàn thành công việc ở mức tốt
- Đồ án đúng tiến độ

### Minh chứng họp nhóm lần 3

**Thông tin chung**
- Thời gian bắt đầu: 22h00, ngày 05/05/2025
- Thời gian kết thúc: 22h30, ngày 25/05/2025
- Địa điểm: Google Meet (<https://meet.google.com/jjp-fsff-oae>)
- Thành viên có mặt:
\+ Nguyễn Hưng Thịnh (Trưởng nhóm)
\+ Võ Cao Tâm Chính
- Vắng mặt: Không

**Nội dung họp**
Đánh giá mực độ hoàn thành công việc được giao:

| Họ Tên | Mức độ hoàn thành | Ghi chú |
| --- | --- | --- |
| Nguyễn Hưng Thịnh | 100% |     |
| Võ Cao Tâm Chính | 100% |     |

Đánh giá tiến độ đồ án
\+ Tiến độ tổng thể: 52% hoàn thành
\+ Tiến độ so với kế hoạch: Đúng tiến độ

Phân công công việc mới

| STT | Họ tên | Vai trò | Công việc | Tỷ lệ phân chia công việc |
| --- | --- | --- | --- | --- |
| 1   | Nguyễn Hưng Thịnh | Nhóm trưởng | Tổng hợp các nội dung báo cáo, release sản phẩm, nộp bài | 50% |
| 2   | Võ Cao Tâm Chính | Thành viên | Tổng hợp các nội dung cần báo cáo, tổng hợp minh chứng các cuộc họp. | 50% |

**Cam kết chung**
- Tuân thủ deadline và các quy tắc lập trình.
- Họp đột xuất nếu có vấn đề phát sinh

**Kết luận**
- Các thành viên đều hoàn thành công việc ở mức tốt
- Đồ án đúng tiến độ

## Thông tin chi tiết đồ án

### Yêu cầu

1. Yêu cầu cụ thể: Sử dụng mã nguồn được cung cấp sẵn viết lại theo hướng đối tượng (OOP), đông thời bổ sung thêm các cải tiến áp dụng các nguyên tắc (SOLID), các design pattern, nguyên lí dependency injction và áp dụng kiến trúc phần mềm tùy chọn.
2. Thời gian thực hiện: 8 tuần
3. Thực hiện đảm bảo mã nguồn bằng:

   a. Quản lí mã nguồn với git: sinh viên tự lựa chọn qui trình, khuyến khích sử dụng “feature branch workflow”

   b. Tài liệu mô tả coding convention: các tiêu chuẩn thống nhất về mã nguồn mà các thành viên phải tuân theo

   c. Kiểm thử bằng unit test. Cần tạo ra test plan, các test case và test report

4. Tạo ra các tài liệu mô tả kiến trúc phần mềm, mô tả các module:

   a. Vẽ class diagram  
   b. Tạo tài liệu mô tả về các lớp, ý nghĩa các hàm

### Cách thức đánh giá

1. Teamwork: 15%. Phân công và theo dõi tiến độ công việc, biên bản họp nhóm.
2. UI/UX: 20%. Chính là điểm chức năng cũng như giao diện của chương trình.
3. Kiến trúc phần mềm + design pattern: 20%. Mô tả bạn đã thiết kế chương trinh theo kiến trúc phần mềm ra sao, tuân thủ theo các nguyên tắc và nguyên lí OOP như thế nào, dùng các design pattern gì.
4. Đảm bảo chất lượng: 20%. test / coding convention.
5. Tài liệu mô tả kiến trúc phần mềm và các module: 10%
6. Các chủ đề nâng cao: 15%. Là các chủ đề có độ khó, độ phức tạp ở mức cao nhóm tự tìm hiểu mà giáo viên không đề cập trên lớp.

<!-- ## Cách thức quản lý nhóm -->

## Đề tài được chọn: [**Travel Agency Management System**](https://www.codewithc.com/travel-agency-management-system-in-c-with-mysql/)

### Tình trạng hiện tại

- Tổ chức mã nguồn còn rời rạc, thiếu tính liên kết.
- Giao diện console app, chưa thực sự thân thiện & gần gũi với người dùng.
- Thiết kế cơ sở dữ liệu còn đơn giản, chưa thực sự chứa đựng đầy đủ thông tin cần thiết.
- Logic chương trình còn sơ khai, chưa hình thành được các luồng sự kiện chính sẽ xuất hiện.

### Kiến trúc phần mềm áp dụng

- Kiến trúc phần mềm được sử dụng trong đồ án: **Mô hình 3-layer**
- Giới thiệu mô hình: gồm có 3 phần chính (hay còn gọi là **lớp**)

  - **Presentation Layer (GUI):** Lớp này có nhiệm vụ chính giao tiếp với người dùng. Nó gồm các thành phần giao diện và thực hiện các công việc như nhập liệu, hiển thị dữ liêu, kiểm tra tính đúng đắn dữ liệu trước khi gọi lớp Business Logic Layer (BLL).

  - **Business Logic Layer (BLL):** Layer này phân ra 2 thành nhiệm vụ:

    - Đây là nơi đáp ứng các yêu cầu thao tác dữ liệu của GUI layer, xử lý chính nguồn dữ liệu từ Presentation Layer trước khi truyền xuống Data Access Layer và lưu xuống hệ quản trị CSDL.
    - Đây còn là nơi kiểm tra các ràng buộc, tính toàn vẹn và hợp lệ dữ liệu, thực hiện tính toán và xử lý các yêu cầu nghiệp vụ, trước khi trả kết quả về Presentation Layer.

  - **Data Access Layer (DAL):** Lớp này có chức năng giao tiếp với hệ quản trị CSDL như thực hiện các công việc liên quan đến lưu trữ và truy vấn dữ liệu ( tìm kiếm, thêm, xóa, sửa,…).

#### Chi tiết mô tả kiến trúc phần mềm

- Presentation Layer (GUI)

  Trách nhiệm:

  - Giao tiếp trực tiếp với người dùng thông qua giao diện đồ họa (Qt Widgets).

  - Hiển thị dữ liệu từ Business Logic Layer (BLL) và chuyển tương tác người dùng (nhấn nút, nhập liệu) xuống BLL.

  Thành phần chính:

  - `LoginWindow`: Xử lý đăng nhập/đăng ký, kết nối với AuthService.

  - `MainWindow`: Cửa sổ chính hiển thị chức năng theo vai trò người dùng (admin/customer).

  - Các Dialog (`AddTripDialog`, `TripListDialog`,...): Tạo giao diện cụ thể cho từng nghiệp vụ.

- Business Logic Layer (BLL)

  Trách nhiệm:

  - Xử lý nghiệp vụ: kiểm tra quyền, validate dữ liệu, tính toán.

  - Đóng vai trò trung gian giữa GUI và Data Access Layer (DAL).

  Thành phần chính:

  - `AuthService`:

    - Quản lý đăng nhập, phân quyền (admin/customer)..

  - `TripService`, `UserService`,...:

    - Kiểm tra quyền trước khi thực hiện các chức năng.

    - Chuyển dữ liệu hợp lệ xuống DAL.

- Data Access Layer (DAL)

  Trách nhiệm:

  - Giao tiếp với database: thực thi truy vấn SQL, ánh xạ dữ liệu thành đối tượng.

  - Đảm bảo tính toàn vẹn dữ liệu.

  Thành phần chính:

  - Repository Pattern:

    - `SqlUserRepository`: Quản lý truy vấn liên quan đến bảng User.

    - `SqlTripRepository`: Xử lý các thao tác với bảng Trip.

  - `DatabaseManager`:

    - Quản lý kết nối database dùng Singleton Pattern.

    - Hỗ trợ transaction và bắt lỗi SQL.

- Ví dụ tương tác giữa các lớp:

  - GUI gọi phương thức từ BLL (ví dụ: tripService->addTrip(trip)).
  - BLL kiểm tra nghiệp vụ, gọi DAL để lưu dữ liệu.
  - DAL thực thi SQL và trả kết quả ngược lên BLL → GUI.

  ```mermaid
   flowchart TD
      A[Presentation Layer] -->|Request| B[Business Logic Layer]
      B -->|Validate| C[Data Access Layer]
      C -->|SQL Query| D[(Database)]
      D -->|Result| C --> B --> A
  ```

### Các tính năng chính đã có

1. Tạo mới chuyến đi cho người dùng

2. Hiển thị danh sách người dùng hiện tại

3. Tìm kiếm người dùng cụ thể

4. Cập nhật lại thông tin người dùng

5. Xóa người dùng

6. Tạo chuyến đi mới

7. Cập nhật lại thông tin chuyến đi

8. Xóa chuyến đi

### Mở rộng

1. Tạo giao diện cho phần mềm

   - Thay vì sử dụng đồ họa console như mã nguồn đã có sẵn, chương trình sẽ được xây dựng thêm **GUI (Graphic User Interface)**, giúp các thao tác trên phần mềm trở nên dễ dàng và trực quan hơn.
   - Framework được sử dụng sẽ là: **Qt** _(có thể thay đổi nếu tìm thấy framework phù hợp hơn)_

2. Chức năng đăng nhập / tạo tài khoản mới

   - Thêm chức năng đăng nhập & tạo tài khoản. Người dùng cần phải có tài khoản để sử dụng phần mềm này.
   - Thông tin tài khoản (tên đăng nhập, mật khẩu, họ tên,...) sẽ đều được lưu trên CSDL, giúp xác thực được người dùng cho nhiều phiên đăng nhập.
   - Bên cạnh đó, thông tin tài khoản còn lưu thêm **vai trò (role)** cụ thể của người dùng, giúp phân quyền các nhóm chức năng cho từng loại user khác nhau.

3. Phân quyền người dùng

   - Đối với mỗi loại người dùng cụ thể (VD: quản trị viên, người dùng thường,...) sẽ có các quyền khác nhau, thay vì có thể thực hiện được mọi chức năng như trong mã nguồn có sẵn. VD: người dùng thường chỉ có thể tạo lập, cập nhật thông tin của họ, chứ không thể thay đổi thông tin của người dùng khác.

4. Thêm module **Review** để lưu trữ đánh giá của người dùng cho chuyến đi tương ứng

   - Mỗi user sẽ có thể đưa ra đánh giá cho các chuyến đi mình đã trải nghiệm.
   - Thông tin 1 bản ghi đánh giá bao gồm: đoạn văn đánh giá (text), điểm rating (1-5), thời gian tạo, chuyến đi được đánh giá, người đánh giá.
   - Chức năng hiển thị các bài đánh giá cho từng chuyến đi cụ thể, hiển thị các bài đánh giá của người dùng hiện đang đăng nhập.

5. Xuất hóa đơn khi khách hàng xác nhận
   - Mỗi khi khách hàng xác nhận chuyến đi hệ thống sẽ tự động tính toán chi phí và xuất ra hóa đơn ra file .txt.
   - Hóa đơn bao gồm: Tên khách hàng, số điện thoại, ngày lập, thông tin chuyến đi, tổng thành tiền.
6. Hiển thị thời tiết tại điểm đến
   - Hiển thị thời tiết 5 ngày tiếp theo tại điểm đến trong chuyến đi đang được khách hàng lựa chọn.
   - Thông tin hiển thị bao gồm: Tên điểm đến, ngày dự đoán, nhiệt độ dự đoán, trạng thái thời tiết.
7. Chuyển đổi ngôn ngữ hiển thị
   - Trên giao diện phần mềm cung cấp tính năng chuyển đổi giữa hai ngôn ngữ Việt - Anh.

### Các nguyên tắc và nguyên lí OOP đã tuân thủ

#### Nguyên tắc SOLID

Đồ án tuân thủ nghiêm ngặt 5 nguyên tắc SOLID để đảm bảo tính mở rộng và dễ bảo trì:

**1. Single Responsibility Principle (SRP)**

**Định nghĩa**: Mỗi lớp chỉ có một trách nhiệm duy nhất, dễ dàng quản lí & kiểm soát chương trình.

**Ví dụ áp dụng trong đồ án:**

- Lớp `SqlTripRepository`, `SqlUserRepository`,...

  - Trách nhiệm duy nhất: Thực hiện các thao tác CRUD với bảng `Trip`, `User` trong database.
  - Code minh họa:

  ```cpp
  class SqlTripRepository {
  public:
   bool addTrip(const Trip& trip); // Chỉ thực hiện các thao tác CRUD vào DB
   QList<Trip> getAllTrips(); // Không chứa logic nghiệp vụ
  };

  ```

- Lớp `TripService`, `UserService`, `AuthService`,...

  - Trách nhiệm duy nhất: Chứa các thông tin nghiệp vụ (tính toán, kiểm tra quyền, validation,...), giải quyết bài toán thực tế của phần mềm. Chứa các chức năng, yêu cầu cụ thể phục vụ cho người sử dụng phần mềm.

  - Code minh họa:

  ```cpp
  class TripService {
  public:
   // Basic CRUD operations, lấy dữ liệu thông qua các lớp Repository trước đó, không liên quan đến database thực sự.
   QList<Trip> getAllTrips();

   // Business logic methods
   QList<Trip> findTripsByDifficulty(const QString& difficulty);

   // Validation
   bool validateTrip(const Trip& trip) const;
  }
  ```

- Lớp `AddTripDialog`, `TripListDialog`, `ShowUserInformationDialog`,...

  - Trách nhiệm duy nhất: Định nghĩa giao diện để người dùng có thể tương tác với phần mềm. Không liên quan đến logic nghiệp vụ và database của phần mềm.

  - Code minh họa:

  ```cpp
   namespace Ui {
   class TripListDialog;
   }

   class TripListDialog : public QDialog
   {
      Q_OBJECT

   private:
      void setupModel();
      void refreshTripList();
      void setupActions(); // Thêm hàm thiết lập actions

   private:
      Ui::TripListDialog *ui; // Đặc trưng của Qt khi làm C++ GUI App
      QSharedPointer<TripService> _tripService; // Lấy/Đẩy dữ liệu thông qua lớp Service
      QStandardItemModel* _model; // Model quản lý dữ liệu
   };
  ```

- Lớp `Trip`, `User`, ...

  - Trách nhiệm duy nhất: Đây là các model của phần mềm (hay _Data Transfer Object - DTO_), chỉ dùng để chứa dữ liệu và đi qua các tầng trong kiến trúc phần mềm.

  - Code minh họa:

  ```cpp
   class User {
      private:
         QString _email;
         QString _password;
         QString _name;
         QString _role;
      public:
         User();
         User(const QString& email, const QString& password, const QString& name, const QString& role);

         QString email() const;
         // other getters...

         void setEmail(const QString& email);
         // other setters...

         bool isValid() const;
   };
  ```

**Lợi ích:** Trong quá trình phát triển phần mềm, nếu cần thay đổi database schema (thêm ảnh, thông tin, thêm logic nghiệp vụ, chức năng...) thì chỉ cần sửa ở một số lớp cụ thể mà không làm ảnh hưởng tới toàn bộ chương trình.

**2. Open / Closed Principle (OCP)**

**Định nghĩa**: Có thể mở rộng các lớp nhưng không sửa đổi code có sẵn.

**Ví dụ áp dụng trong đồ án:**

- Thêm service mới (ví dụ: `BookingService`, `PaymentService`) bằng cách inject vào GUI thông qua constructor, không cần sửa `MainWindow`.

  - Code minh họa:

  ```cpp
  MainWindow::MainWindow(QSharedPointer<AuthService> authService,
                     QSharedPointer<TripService> tripService,
                     QSharedPointer<BookingService> bookingService)
  ```

- Mở rộng/Thay đổi kiểu database

  - Trách nhiệm duy nhất: Sử dụng interface `TripRepository`, `UserRepository` để sau này có thể thêm kiểu cơ sở dữ liệu phi quan hệ (Ví dụ: `MongoTripRepository`) vào chương trình, không ảnh hưởng đến các lớp khác.

  - Code minh họa:

  ```cpp
   class TripService {
   private:
      QSharedPointer<TripRepository> _repository; // sử dụng interface thay vì concrete class
      bool validateTrip(const Trip& trip) const;

   public:
      explicit TripService(QSharedPointer<TripRepository> repository, QObject* parent = nullptr);
   };
  ```

**Lợi ích:** Chương trình sẽ **cho phép** mở rộng thêm các tính năng một cách dễ dàng, linh hoạt để đáp ứng nhu cầu của khách hàng, trong khi **không cho phép** thay đổi code có sẵn - điều sẽ rất dễ gây ra các bug không mong muốn.

**3. Liskov Substitution Principle (LSP)**

**Định nghĩa**: Lớp con phải thay thế được lớp cha mà không phá vỡ chương trình.

**Ví dụ áp dụng trong đồ án:**

- Các repository (`SqlUserRepository`, `SqlTripRepository`) đều kế thừa từ interface (`UserRepository`, `TripRepository`), đảm bảo có thể hoán đổi khi cần chuyển từ SQL sang NoSQL. _(đã trình bày ở nguyên tắc 2 - Open/Closed Principle)_

- Sử dụng cho Testing: Dù là `SqlUserRepository` hay `MockUserRepository` (dùng cho test), `AuthService` vẫn hoạt động đúng.

**Lợi ích:** Liskov Substitution Principle (LSP) giúp đảm bảo rằng lớp con có thể thay thế lớp cha mà không làm thay đổi hành vi của hệ thống, từ đó giúp hệ thống ổn định, dễ mở rộng và tránh lỗi do kế thừa sai cách.

**4. Interface Segregation Principle (ISP)**

**Định nghĩa**: Client không nên phụ thuộc vào interface mà nó không dùng.

**Ví dụ áp dụng trong đồ án:**

- Interface **nhỏ, chuyên biệt**: Tách thành 2 interface `TripRepository` và `UserRepository` thay vì một interface lớn `Repository`.

- Vì `AuthService` chỉ cần các thông tin và các hàm liên quan đến `User` như `addUser()`, `getUserByEmail()`,... nên chỉ cần tiêm dependency `UserRepository` vào `AuthService`, giảm sự phụ thuộc thừa.

  - Code minh họa:

  ```cpp
   // ✅ Đúng ISP
   class UserRepository {
   public:
      virtual bool addUser(const User& user) = 0;
      virtual QSharedPointer<User> getUserByEmail(const QString& email) = 0;
   };

   class TripRepository {
   public:
      virtual bool addTrip(const Trip& trip) = 0;
      virtual QList<Trip> getAllTrips() = 0;
   };

   //.......
   // Các service
   class AuthService {
   private:
      QSharedPointer<UserRepository> _userRepository; // chỉ phụ thuộc vào UserRepository
      QSharedPointer<User> _currentUser; // lưu lại user hiện tại
   };

  ```

**Lợi ích:** Giúp giảm sự phụ thuộc thừa cho chương trình (`AuthService` chỉ phụ thuộc vào `UserRepository`, không biết gì về `TripRepository`), cũng như dễ bảo trì cho chương trình (Thêm/xóa phương thức trong `TripRepository` không làm hỏng `AuthService`).

**5. Dependency Inversion Principle (DIP)**

**Định nghĩa**: Thay vì để module cấp cao không phụ thuộc vào module cấp thấp, cả hai nên phụ thuộc vào abstraction.

**Ví dụ áp dụng trong đồ án:**

- Định nghĩa abstraction (interface) cho repository.

  - Code minh họa:

  ```cpp
   // ✅ Đúng DIP
   class UserRepository {
   public:
      virtual QSharedPointer<User> getUserByEmail(const QString& email) = 0;
      virtual bool addUser(const User& user) = 0;
   };
  ```

- Module cấp cao (AuthService) phụ thuộc vào interface.

  - Code minh họa:

  ```cpp
   class AuthService {
   private:
      QSharedPointer<UserRepository> _userRepo; // Phụ thuộc vào abstraction
   public:
      AuthService(QSharedPointer<UserRepository> repo) : _userRepo(repo) {}
   };
  ```

- Module cấp thấp (`SqlUserRepository`) _implement_ interface.

  - Code minh họa:

  ```cpp
   class SqlUserRepository : public UserRepository {
   public:
      QSharedPointer<User> getUserByEmail(const QString& email) override {
         // Logic truy vấn từ SQL database
      }
   };
  ```

- Sơ đồ mô tả luồng chương trình

  ```mermaid
  sequenceDiagram
   participant GUI as MainWindow
   participant BLL as AuthService
   participant DAL as SqlUserRepository
   GUI->>BLL: login("user@example.com", "pass123")
   BLL->>DAL: getUserByEmail("user@example.com")
   DAL-->>BLL: User object
   BLL-->>GUI: Kết quả đăng nhập
  ```

- Cài đặt code

  - `MainWindow` gọi `AuthService` (cấp cao).
  - `AuthService` gọi `UserRepository` (abstraction), không biết chi tiết là SQL hay NoSQL.

- Ví dụ mở rộng (sử dụng NoSQL Database)

  ```cpp
  class MongoUserRepository : public UserRepository {
  public:
     QSharedPointer<User> getUserByEmail(const QString& email) override {
        // Logic truy vấn từ MongoDB
     }
  };

  // Trong main.cpp
  auto userRepo = QSharedPointer<MongoUserRepository>::create();
  auto authService = QSharedPointer<AuthService>::create(userRepo);
  ```

**Lợi ích:** Giảm coupling giữa các lớp. Dễ dàng thay thế, mở rộng module mà không cần sửa code hiện có.

#### Nguyên lí Dependency Injection (DI)

**Định nghĩa**: Cung cấp các dependency (phụ thuộc) từ bên ngoài vào một lớp thay vì để lớp tự khởi tạo chúng.

**Ví dụ áp dụng trong đồ án:**

- Khởi Tạo Dependency: Trong `main.cpp`, tất cả dependency được khởi tạo và inject vào các lớp cần thiết.

  ```cpp
  int main() {
   // 1. Khởi tạo repository
   auto userRepo = QSharedPointer<SqlUserRepository>::create(DatabaseManager::getInstance());

   // 2. Inject repository vào AuthService
   auto authService = QSharedPointer<AuthService>::create(userRepo);

   // 3. Inject AuthService vào LoginWindow
   LoginWindow loginWindow(authService);
  }
  ```

- DI Trong Service Layer: `TripService` nhận `TripRepository` qua constructor.

  ```cpp
  class TripService {
  private:
     QSharedPointer<TripRepository> _tripRepo;
  public:
     TripService(QSharedPointer<TripRepository> repo) : _tripRepo(repo) {}

     bool addTrip(const Trip& trip) {
        return _tripRepo->addTrip(trip); // Gọi abstraction, không phụ thuộc implementation
     }
  };
  ```

- DI Trong UI Layer: `MainWindow` nhận các service qua constructor.

  ```cpp
  MainWindow::MainWindow(QSharedPointer<AuthService> authService,
                       QSharedPointer<TripService> tripService)
     : _authService(authService), _tripService(tripService)
  {
     // Kết nối signal-slot
     connect(_tripService.data(), &TripService::tripAdded,
           this, &MainWindow::onTripAdded);
  }
  ```

**Lợi ích**: DI là xương sống của kiến trúc phần mềm hiện đại, giúp đồ án trở nên linh hoạt, dễ bảo trì. Đây còn là nền tảng để áp dụng nguyên tắc SOLID. Kết hợp cùng Interface để tuân thủ _Dependency Inversion Principle (DIP)_ và _Smart Pointer_ để quản lí vùng nhớ an toàn.

### Các Design Pattern đã áp dụng

**1. Singleton Pattern**

**Mục đích:** Đảm bảo chỉ có một instance duy nhất của một lớp trong toàn bộ ứng dụng.

**Ví dụ áp dụng trong đồ án:**

- Lớp `DatabaseManager`: Quản lý kết nối database toàn cục.

  - Code minh họa:

    ```cpp
    class DatabaseManager {
    private:
       static DatabaseManager* _instance; // Biến static
       DatabaseManager() {} // Constructor private

    public:
       static DatabaseManager& getInstance() {
          if (!_instance) _instance = new DatabaseManager();
          return *_instance;
       }
    };
    ```

  - Ví dụ sử dụng:

    ```cpp
    // Truy cập database từ bất kỳ đâu
    DatabaseManager& db = DatabaseManager::getInstance();
    QSqlDatabase connection = db.getConnection();
    ```

**Lợi ích:** Tiết kiệm tài nguyên kết nối đến database. Đảm bảo tính nhất quán của dữ liệu, tránh trường hợp xung đột khi có nhiều hơn 1 instance cùng ghi vào một database.

**2. Repository Pattern**

**Mục đích:** Tách biệt logic truy cập dữ liệu khỏi logic nghiệp vụ.

**Ví dụ áp dụng trong đồ án:**

- Các lớp `SqlUserRepository`, `SqlTripRepository`.

  - Code minh họa:

    ```cpp
    class UserRepository {
    public:
       virtual bool addUser(const User& user) = 0;
       virtual QSharedPointer<User> getUserByEmail(const QString& email) = 0;
    };

    class SqlUserRepository : public UserRepository {
    public:
       bool addUser(const User& user) override {
          // Logic thêm user vào SQL database
       }
    };
    ```

  - Ví dụ sử dụng:

    ```cpp
    auto userRepo = QSharedPointer<SqlUserRepository>::create(DatabaseManager::getInstance());
    AuthService authService(userRepo);
    ```

**Lợi ích:** Dễ dàng thay đổi database (SQL → NoSQL, hoặc sử dụng file text,...) mà không ảnh hưởng đến service layer. Chuyên biệt chức năng của từng tầng, giúp kiểm soát & phát triển phần mềm dễ dàng hơn.

**3. Observer Pattern**

**Mục đích:** Giúp các đối tượng phản ứng với sự kiện từ đối tượng khác.

**Ví dụ áp dụng trong đồ án:**

- **Signal-Slot trong Qt**: Kết nối giữa GUI và service layer.

  - Code minh họa:

    ```cpp
    // TripService phát signal khi có lỗi
    class TripService : public QObject {
       Q_OBJECT
    signals:
       void errorOccurred(const QString& message);
    };

    // MainWindow lắng nghe signal
    MainWindow::MainWindow(QSharedPointer<TripService> tripService) {
       connect(tripService.data(), &TripService::errorOccurred,
             this, &MainWindow::showError);
    }
    ```

**Lợi ích:** Giảm coupling giữa GUI và business logic. Đồng thời, GUI sẽ được tự động cập nhật khi dữ liệu thay đổi.



### Đảm bảo chất lượng

**1\. Single Branch Workflow**

**Giới Thiệu Chung**

Single Branch Workflow (Quy trình làm việc một nhánh) là một cách tiếp cận đơn giản trong quản lý mã nguồn bằng Git, nơi toàn bộ dự án chỉ sử dụng **một nhánh chính duy nhất** (thường là main hoặc master). Mọi thay đổi đều được commit trực tiếp lên nhánh này mà không tạo các nhánh phụ (feature branches).

**Đối tượng phù hợp**

- Dự án cá nhân nhỏ
- Prototype hoặc demo nhanh
- Team nhỏ (2-3 người) làm việc trên cùng một tính năng
- Dự án không yêu cầu code review phức tạp

**Ưu điểm**

- **Đơn giản, dễ triển khai**: Không cần quản lý nhiều nhánh, giảm phức tạp khi merge.
- **Lịch sử commit thẳng (linear history)**: Dễ theo dõi thay đổi vì không có merge commit.
- **Phù hợp CI/CD**: Mọi commit đều có thể trigger build/deploy ngay lập tức.
- **Tốc độ nhanh**: Không mất thời gian tạo/tách nhánh, phù hợp cho dự án cần release nhanh.

**Nhược điểm**

- **Không phù hợp cho dự án lớn**: Khó quản lý khi nhiều người cùng làm nhiều tính năng song song.
- **Rủi ro cao**: Code chưa hoàn thiện có thể ảnh hưởng đến nhánh chính.
- **Khó review code**: Không có Pull Request/Merge Request để kiểm tra trước khi tích hợp.

**Cách Thức Hoạt Động**

**Khởi tạo dự án**

```bash
git init
git checkout -b main  # Tạo nhánh chính
```

**Làm việc trực tiếp trên** main

```bash
git add .
git commit -m "Thêm tính năng X"
git push origin main
```

**Không tạo nhánh phụ**, mọi thay đổi đều đẩy thẳng lên main.

**Kết Luận**

Single Branch Workflow là lựa chọn tối ưu cho:

- **Cá nhân** làm dự án nhỏ, không cần phân nhánh.
- **Team startup** cần release nhanh, ít quy trình.
- **Prototyping** hoặc demo POC (Proof of Concept).

**2\. Hướng dẫn Coding Invention**

#### Mục đích

- Tăng tính rõ ràng, bảo trì
- Giảm lỗi tiềm ẩn
- Tối ưu hiệu năng
- Tuân thủ best practices từ C++ Core Guidelines

#### Các quy tắc cần tuân thủ

Quản lý Header Files (SF)

- SF.7: Không dùng “using namespace” ở global scope trong header file
- SF.8: Luôn dùng #include guards
- SF.12: Dùng “” cho file local, <> cho system/library

Ví dụ:

```cpp
//SF.8: #include guard
#ifndef MATH_UTILS_H
#define MATH_UTILS_H

//SF.7: Không dùng 'using namespace' ở global scope

//SF.12: Include thư viện hệ thống với <>
#include <cmath>
double squareRoot(double x) {
    return std::sqrt(x);  // Không cần 'using namespace std'
}

#endif // MATH_UTILS_H
```

Style & Readability (NL)

- NL.21 / ES.10: Khai báo một biến mỗi dòng
- NL.18: Dùng C++-style declarator
- NL.5: Tránh mã hóa kiểu vào tên biến

Ví dụ:

```cpp
#include <string>

int main() {
    std::string userName = "John";
    int userId = 12345;
    int* pointer = nullptr;
    //NL.18: C++-style declarator (đặt * và & sát kiểu dữ liệu)
    //NL.5: Không mã hóa kiểu vào tên biến
    //NL.21: Mỗi biến khai báo trên 1 dòng

    return 0;
}
```

Khởi tạo & Phạm vi Biến (ES)

- ES.20: Luôn khởi tạo biến
- ES.21: Khai báo biến gần nơi dùng nhất
- ES.22: Chỉ khai báo khi có giá trị khởi tạo
- NR.1: Không bắt buộc khai báo ở đầu hàm

Ví dụ:

```cpp
#include <iostream>
#include <vector>
#include <random>

int main() {
    //ES.20: Luôn khởi tạo biến ngay khi khai báo
    const int maxAttempts = 3;  // Khởi tạo ngay
    std::vector<int> numbers = {1, 2, 3};  // Khởi tạo ngay

    //NR.1: Không bắt buộc khai báo tất cả biến ở đầu hàm
    for (int i = 0; i < maxAttempts; ++i) {
        //ES.21: Khai báo biến gần nơi dùng nhất
        std::random_device rd;
        std::mt19937 gen(rd());

        //ES.22: Chỉ khai báo khi có giá trị khởi tạo
        const int randomValue = std::uniform_int_distribution<>(1, 100)(gen);

        std::cout << "Lần thử " << i + 1 << ": " << randomValue << '\n';

        if (randomValue > 50) {
            //ES.21: Khai báo biến ngay khi cần
            const std::string successMsg = "Thành công!";
            std::cout << successMsg << '\n';
            break;
        }
    }

    return 0;
}
```

Xử lý Lỗi & Logic (F, NR)

- NR.3: Ưu tiên dùng exception thay vì error code
- F.56: Tránh lồng điều kiện không cần thiết
- NR.2: Không bắt buộc một return duy nhất

Ví dụ:

```cpp
#include <iostream>
#include <stdexcept>
#include <string>

// Hàm đăng nhập sử dụng exception (NR.3)
void login(const std::string& username, const std::string& password) {
    if (username.empty()) {
        throw std::invalid_argument("Tên đăng nhập không được trống");
    }
    if (password.empty()) {
        throw std::invalid_argument("Mật khẩu không được trống");
    }
    if (password.length() < 6) {
        throw std::runtime_error("Mật khẩu phải có ít nhất 6 ký tự");
    }

    std::cout << "Đăng nhập thành công!\n";
}

int main() {
    try {
        std::string username = "user123";
        std::string password = "pass";  // Mật khẩu ngắn để demo lỗi

        // F.56: Tránh lồng điều kiện không cần thiết bằng cách dùng early return
        if (username == "admin") {
            std::cout << "Chào admin!\n";
            return 0;  // NR.2: Không bắt buộc 1 return duy nhất
        }

        login(username, password);

        // Các xử lý khác...
        std::cout << "Thực hiện các thao tác...\n";
        return 0;  // NR.2: Có thể có nhiều return

    } catch (const std::exception& e) {  // NR.3: Bắt exception
        std::cerr << "Lỗi: " << e.what() << "\n";
        return 1;
    }
}
```

Hằng số & So sánh (ES)

- ES.45: Tránh magic numbers, dùng hằng số
- Const on left: Đặt hằng số bên trái phép so sánh
- ES.47: Dùng “nullptr” thay vì “0” hay ”NULL”

Ví dụ:

```cpp
#include <iostream>
#include <memory>

int main() {
    // ES.45: Dùng hằng số thay magic numbers
    constexpr int MAX_RETRIES = 3;
    constexpr int MIN_PASSWORD_LENGTH = 6;
    constexpr int ADMIN_ID = 42;

    // ES.47: Dùng nullptr thay vì NULL/0
    std::unique_ptr<int> ptr = nullptr;

    // Const on left: hằng số bên trái phép so sánh
    if (nullptr == ptr) {
        ptr = std::make_unique<int>(ADMIN_ID);
    }

    int userInput;
    std::cout << "Nhập mật khẩu mới: ";
    std::cin >> userInput;

    // ES.45 + Const on left
    if (MIN_PASSWORD_LENGTH <= userInput) {
        std::cout << "Mật khẩu hợp lệ!\n";
    } else {
        std::cout << "Mật khẩu phải có ít nhất "
                  << MIN_PASSWORD_LENGTH << " ký tự\n";
    }

    // Const on left
    if (ADMIN_ID == *ptr) {
        std::cout << "Xin chào Admin!\n";
    }

    return 0;
}
```

Biểu thức & Toán tử (ES)

- ES.41: Dùng ngoặc đơn khi nghi ngờ độ ưu tiên
- ES.43: Tránh biểu thức có thứ tự tính không xác định
- ES.87: Không thêm “== true” hay ”!= false” thừa

Ví dụ:

```cpp
#include <iostream>
#include <vector>

int main() {
    // ES.41: Dùng ngoặc đơn khi nghi ngờ độ ưu tiên
    int a = 5, b = 3, c = 2;
    int result = (a + b) * c;  // Rõ ràng về thứ tự tính toán
    std::cout << "Kết quả: " << result << "\n";

    // ES.43: Tránh biểu thức có thứ tự tính không xác định
    int j = 0;
    nums[j] = j + 10;    //Đảm bảo thứ tự rõ ràng
    j++;

    // ES.87: Không thêm == true/!= false thừa
    bool isValid = true;
    if (isValid) {       //Tốt - không dùng (isValid == true)
        std::cout << "Dữ liệu hợp lệ\n";
    }

    if (!isValid) {      //Tốt - không dùng (isValid == false)
        std::cout << "Dữ liệu không hợp lệ\n";
    }

    return 0;
}
```

I/O & Hiệu suất (SL)

- SL.io.50: Tránh “std::endl” (gọi flush không cần thiết)

Ví dụ:

```cpp
#include <iostream>
#include <fstream>

int main() {
    //Cách viết tốt - dùng '\n' thay vì std::endl
    std::ofstream file("output.txt");  // Mở file để ghi

    // Ghi 5 dòng vào file
    for (int i = 1; i <= 5; ++i) {
        file << "This is line " << i << '\n';  // Chỉ xuống dòng, không flush
    }

    // Chỉ flush khi thực sự cần thiết
    file.flush();  // Đẩy dữ liệu từ bộ đệm xuống file

    // Ví dụ xuất ra console
    std::cout << "Operation completed successfully.\n";  // Không dùng std::endl

    return 0;
}
```

#### Thực hiện Unit Test với các lớp đã được sử dụng

\- Trước khi kiểm thử thực hiện tách phần Logic và UI để đảm bảo độ ổn định cao và dễ dàng trong quá trình kiểm thử chức năng.

**3\. Thực hiện Unit Test với các lớp đã được** sử dụng

**Giới Thiệu**

Tài liệu này mô tả kế hoạch kiểm thử các chức năng chính của hệ thống:

- UserService (Quản lý người dùng)
- AuthService (Đăng nhập/Đăng ký)
- TripService (Quản lý chuyến đi)

**Mục Tiêu Kiểm Thử**

- Xác minh hoạt động đúng của các service
- Kiểm tra tương tác với database
- Xử lý lỗi và các trường hợp biên
- Đảm bảo logic nghiệp vụ

**Môi Trường Kiểm Thử**

- Hệ điều hành: Windows
- Database: SQL Server (Azure)
- Thư viện: Qt 6.x, ODBC Driver
- Công cụ: Kiểm thử thủ công (không dùng framework bên ngoài)

**Các Trường Hợp Kiểm Thử**
Thực hiện kiểm thử thủ công bằng cách tạo ra các hàm kiểm thử lớp “UserService” mô phỏng lại các hàm đã sử dụng (**user**, **updateUser**, **getUserByEmail, deleteUser**).
Hàm thử:

```cpp
void testUserService(DatabaseManager& db) {
    std::cout << "Running UserService tests...\n";

    // Mock repository
    QSharedPointer<SqlUserRepository> mockRepo = QSharedPointer<SqlUserRepository>::create(db);
    UserService userService(mockRepo);

    // Test addUser
    User user("test@example.com", "password123", "Test User", "customer");
    assert(userService.updateUser(user.email(), user.password(), user.name()) == false); // User chưa tồn tại

    mockRepo->addUser(user);
    assert(userService.getUserByEmail("test@example.com")->email() == "test@example.com"); // Lấy user thành công
    assert(userService.deleteUser("test@example.com") == true); // Xóa user thành công

    std::cout << "UserService tests passed!\n";
}
```

Dựa trên hàm kiểm thử ta thu được kết quả với các hàm đã được dùng với UserService:

| STT | Hàm kiểm thử   | Kết quả trả về                                   | Kết quả kiểm thử |
| --- | -------------- | ------------------------------------------------ | ---------------- |
| 1   | updateUser     | Thực thi thất bại do không tìm thấy email hợp lệ | PASS             |
| 2   | addUser        | Thêm user thành công                             | PASS             |
| 3   | getUserByEmail | Lấy user thành công                              | PASS             |
| 4   | deleteUser     | Xóa thành công                                   | PASS             |

Thực hiện kiểm thử thủ công bằng cách tạo ra các hàm kiểm thử lớp “AuthService” mô phỏng lại các hàm đã sử dụng (**login**, **signup**).
Hàm thử

```cpp
void testAuthService(DatabaseManager& db) {
    std::cout << "Running AuthService tests...\n";

    // Mock repository
    QSharedPointer<SqlUserRepository> mockRepo = QSharedPointer<SqlUserRepository>::create(db);
    AuthService authService(mockRepo);

    // Test signup
    assert(authService.signup("test@example.com", "password123", "Test User") == true); // Đăng ký thành công
    assert(authService.signup("test@example.com", "password123", "Test User") == false); // Email đã tồn tại

    // Test login
    assert(authService.login("test@example.com", "password123") == true); // Đăng nhập thành công
    assert(authService.login("test@example.com", "wrongpassword") == false); // Sai mật khẩu
    assert(authService.login("nonexistent@example.com", "password123") == false); // Email không tồn tại

    std::cout << "AuthService tests passed!\n";
}
```

Dựa trên hàm kiểm thử ta thu được kết quả với các hàm đã được dùng với AuthService:

| STT | Hàm kiểm thử | Trường hợp                        | Kết quả trả về                       | Kết quả kiểm thử |
| --- | ------------ | --------------------------------- | ------------------------------------ | ---------------- |
| 1   | signup       | Đăng ký hợp lệ                    | Thực thi thành công                  | PASS             |
| 2   | signup       | Đăng ký trùng email               | Thông báo Email đã tồn tại           | PASS             |
| 3   | login        | Đăng nhập hợp lệ                  | Thực thi thành công                  | PASS             |
| 4   | login        | Đăng nhập sai mật khẩu            | Thông báo đăng nhập không thành công | PASS             |
| 5   | login        | Đăng nhập với email không tồn tại | Thông báo đăng nhập không thành công | PASS             |

Đánh giá kiểm thử các lớp và hàm liên quan đên AuthService

- Tổng số test case: 5
- Số lượng test case thành công: 5
- Số lượng test case thất bại: 0
- Tỷ lệ thành công: 100%

→ Các test case thành công cho thấy các chức năng hoạt động đúng như mong đợi.
| STT | Hàm kiểm thử | Trường hợp | Kết quả trả về | Kết quả kiểm thử |
| --- | --- | --- | --- | --- |
| 1 | signup | Đăng ký hợp lệ | Thực thi thành công | PASS |
| 2 | signup | Đăng ký trùng email | Thông báo Email đã tồn tại | PASS |
| 3 | login | Đăng nhập hợp lệ | Thực thi thành công | PASS |
| 4 | login | Đăng nhập sai mật khẩu | Thông báo đăng nhập không thành công | PASS |
| 5 | login | Đăng nhập với email không tồn tại | Thông báo đăng nhập không thành công | PASS |

Thực hiện kiểm thử thủ công bằng cách tạo ra các hàm kiểm thử lớp “TripService” mô phỏng lại các hàm đã sử dụng (**createTrip**, **getAllTrips, deleteTrip**).
Hàm thử

```cpp
void testTripService(DatabaseManager& db) {
    std::cout << "Running TripService tests...\n";

    // Mock repository
    QSharedPointer<SqlTripRepository> mockRepo = QSharedPointer<SqlTripRepository>::create(db);
    TripService tripService(mockRepo);

    // Test createTrip
    Trip trip(0, "Trip to Paris", 5, 1000, "Easy", 10, "A wonderful trip to Paris","TOP1");
    assert(tripService.createTrip(trip) == true); // Tạo trip thành công
    assert(tripService.createTrip(trip) == false); // Tên trip đã tồn tại

    // Test getAllTrips
    QList<Trip> trips = tripService.getAllTrips();
    assert(trips.size() == 1); // Có 1 trip trong danh sách

    // Test deleteTrip
    assert(tripService.deleteTrip(trip.getTripId()) == true); // Xóa trip thành công
    assert(tripService.deleteTrip(trip.getTripId()) == false); // Trip không tồn tại

    std::cout << "TripService tests passed!\n";
}
```

Dựa trên hàm kiểm thử ta thu được kết quả với các hàm đã được dùng với TripService:

| STT | Hàm kiểm thử           | Trường hợp                       | Kết quả trả về            | Kết quả kiểm thử |
| --- | ---------------------- | -------------------------------- | ------------------------- | ---------------- |
| 1   | createTrip             | Tạo Trip thành công              | Thực thi thành công       | PASS             |
| 2   | createTrip             | Tạo Trip với thông tin trùng lặp | Tên Trip đã tồn tại       | PASS             |
| 3   | getAllTrips            |                                  | Trả về danh sách các Trip | PASS             |
| 4   | deleteTrip + getTripId | TripId tồn tại                   | Xóa thành công            | PASS             |
| 5   | deleteTrip + getTripId | TripId không tồn tại             | Trip không tồn tại        |                  |

**Tiêu chí hoàn thành**

- Tất cả test case được thực thi
- Tỷ lệ pass 100%
- Không có lỗi nghiêm trọng
- Độ bao phủ code >80%

  **Phụ lục**
  Nhật ký thực thi

```bash
[PASS] UserService - Thêm/Xóa/Cập nhật user
[PASS] AuthService - Đăng nhập/Đăng ký
[PASS] TripService - Quản lý chuyến đi
```

Đánh giá kiểm thử các lớp và hàm liên quan đên TripService

- Tổng số test case: 5
- Số lượng test case thành công: 5
- Số lượng test case thất bại: 0
- Tỷ lệ thành công: 100%

→ Các test case thành công cho thấy các chức năng hoạt động đúng như mong đợi.

#### Kết luận

Các chức năng đã được sử dụng hoạt động đúng theo yêu cầu, đảm bảo tính chính xác.

## Hướng dẫn cài đặt & build chương trình (trên Windows)

**1. Cài đặt Qt Creator**

- Truy cập đường link sau: https://www.qt.io/download-qt-installer-oss

- Chọn hệ điều hành tương ứng (_Windows x64_).

- Sau khi download thành công, chạy file exe vừa tải về dưới quyền Administrator.

- Cửa sổ cài đặt **Qt Online Installer** sẽ hiện ra, làm theo các bước sau:

  - Màn hình **Welcome** -> Chọn **Next**.

  - Màn hình **Login** -> Tiến hành tạo tài khoản nếu chưa có, hoặc đăng nhập nếu đã có tài khoản.

  - Tích vào **Disable sending usage statistics** -> Nhấn **Next**.

  - Tích vào **I have read agree to the terms and conditions of using Open Source Qt** và **I'm an individual and do not use Qt for any company** -> Nhấn **Next**.

  - Chọn packages **Qt 6.9 for desktop development**

  - Chọn **CMake License Agreement** -> Tích **I have read and agree..** -> Chọn **Next** đến khi nào nút **Install** hiện ra -> Chọn **Install**.

  - Chờ đến khi download xong toàn bộ là đã cài đặt thành công.

- **Lưu ý:** Sau khi Qt Installer bắt đầu cài đặt, rất dễ gặp lỗi _"Network error while downloading..."_. Khắc phục bằng cách chạy lại Qt Installer và chọn một bản mirror cụ thể. Chi tiết như sau:

  - Mở PowerShell, đi đến thư mục chứa Qt Installer (file .exe tải ban đầu).

  - Chạy file cài đặt và chỉ định rõ mirror:

    VD: `installer(.exe) --mirror http://www.nic.funet.fi/pub/mirrors/download.qt-project.org`

  - Nếu vẫn lỗi, hãy tiếp tục chọn một mirror khác cho đến khi thành công.

  - Chi tiết hướng dẫn [**tại đây.**](https://wiki.qt.io/Online_Installer_4.x#Selecting_a_mirror_for_opensource)

**2. Cài đặt ODBC Driver cho SQL Server**

- Tải driver mới nhất từ Microsoft:

  ```powershell
   winget install Microsoft.ODBC.Driver.18.for.SQLServer
  ```

  Hoặc tải thủ công: https://learn.microsoft.com/en-us/sql/connect/odbc/download-odbc-driver-for-sql-server

- Kiểm tra driver đã cài::

  ```powershell
  Get-OdbcDriver -Name "*SQL Server*"
  ```

  Phải hiển thị ít nhất 1 driver (vd: ODBC Driver 18 for SQL Server)

**3. Mở Project với Qt Creator**

- Mở ứng dụng Qt Creator vừa cài đặt.

- Chọn **Open Project** -> Chọn đến file **CMakeLists.txt** trong thư mục mã nguồn của đồ án.

- Chọn **configure** project nếu project chưa được configure tự động.

- Chọn **Run** hoặc **Debug** để build chương trình.

## Timeline & Tasks

### Giai đoạn: 3/4 – 9/4

| **Công việc dự kiến**                                                                                                                                                                                                        | **Ước lượng (man hour)** | **Sản phẩm** |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------ | ------------ |
| - Nhận yêu cầu từ giảng viên <br> - Lựa chọn mã nguồn phù hợp <br> - Lên kế hoạch, chọn công cụ bắt đầu dự án <br> - Đề xuất các phương án mở rộng mã nguồn <br> - Tìm hiểu nguyên tắc, design pattern, dependency injection | 28                       | Project Plan |

---

### Sprint 1: 10/4 – 20/5

| Công việc                                   | Ước lượng (man-hour) | Sản phẩm                         |
| ------------------------------------------- | -------------------- | -------------------------------- |
| Thống nhất tài liệu mô tả coding convention | 16                   | Tài liệu mô tả coding convention |
| Thiết kế lại mã nguồn hướng đối tượng       | 28                   | Class Diagram                    |
| Thiết kế cơ sở dữ liệu                      | 12                   | Database Schema                  |
| Thiết kế giao diện (UI)                     | 12                   | Bản phát họa giao diện           |
| Xây dựng CSDL trên SQL Server               | 20                   | Cơ sở dữ liệu trên SQL Server    |
| Viết mã nguồn cho toàn bộ dự án             | 56                   | Mã nguồn hoàn chỉnh              |
| Vẽ giao diện cho sản phẩm                   | 32                   | Giao diện sản phẩm               |

---

### Sprint 2: 21/5 – 27/5

| Công việc                       | Ước lượng (man-hour) | Sản phẩm            |
| ------------------------------- | -------------------- | ------------------- |
| Kiểm thử bằng unit test         | 4                    | Báo cáo kiểm thử    |
| Kiểm thử truy vấn cơ sở dữ liệu | 4                    | Báo cáo kiểm thử    |
| Kiểm thử giao diện              | 4                    | Báo cáo kiểm thử    |
| Sửa lỗi và hoàn thiện sản phẩm  | 16                   | Sản phẩm hoàn thiện |

---

### Finalizing: 28/5 – 30/5

| Công việc                                        | Ước lượng (man-hour) | Sản phẩm                            |
| ------------------------------------------------ | -------------------- | ----------------------------------- |
| Hoàn thành Auto-generated Documentation          | 4                    | Tài liệu Oxygen comment             |
| Hoàn thành nhật kí, báo cáo, tài liệu giới thiệu | 8                    | Tài liệu hoàn chỉnh phục vụ báo cáo |

---
